# 목차
* [목차](#목차)
* [Tree](#tree)
    + [Tree의 구조와 특징](#tree의-구조와-특징)
    + [Tree는 어디에 사용할까?](#tree는-어디에서-사용할까)
* [Binary Search Tree](#binary-search-tree)
    + [이진 트리(Binary Tree)](#이진-트리binary-tree)
    + [이진 탐색 트리(Binary Search Tree](#이진-탐색-트리binary-search-tree)

# Tree

> 그래프의 여러 구조 중 단방향 그래프의 한 구조로, 데이터가 바로 아래에 있는 하나 이상의 데이터에 무방향으로 연결된 계층적 구조이다.
> 
- 데이터를 순차적으로 나열시킨 선형 구조가 아니라, 하나의 데이터 아래에 여러 개의 데이터가 존재할 수 있는 **비선형 구조**이다. 아래로만 뻗어나가기 때문에 사이클이 없다.

## Tree의 구조와 특징

- 루트(Root) : 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)으로 연결한다.
- 노드(Node) : 각 데이터를 뜻하며, 두 개의 노드가 상하 계층으로 연결되면 부모/자식 관계를 가진다.
    - 부모 노드(Parent Node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 가까운 노드
    - 자식 노드(Child Node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 먼 노드
    - 리프 노드(Leaf Node) : 트리 구조의 끝 지점이고, 자식 노드가 없는 노드

### 깊이(depth)

트리 구조에서는 **루트로부터 하위 계층의 특정 노드까지의 깊이(depth)**를 표현할 수 있다. 루트 노드는 지면에 있는 것처럼 깊이가 0이다. 위 그림에서 루트A는 0이고, B와 C의 depth는 1이다. D, E, F, G의 깊이는 2이다.

### 레벨(Level)

트리 구조에서 **같은 깊이를 가지고 있는 노드를 묶어서 레벨(level)**로 표현할 수 있다. depth가 0인 루트 A의 level은 1이다. depth가 1인 B와 C의 level은 2이다. **같은 레벨에 나란히 있는 노드를 형제 노드(Sibling Node)**라고 한다.

### 높이(Height)

트리 구조에서 **리프 노드를 기준으로 루트까지의 높이(height)를 표현할 수 있다**. 리프 노드와 직간접적으로 연결된 노드의 높이를 표현하며, 부모 노드는 자식 노드의 가장 높은 height 값에 +1한 값을 높이로 가진다. 트리 구조의 높이를 표현할 때에는 각 리프 노드의 높이를 0으로 놓는다. H, I, E, F, J의 높이는 0이다. D와 G의 높이는 1이다. B와 C의 높이는 2이다. 이 때 B는 `D의 height + 1` 을, C는 `G의 height + 1` 을 높이로 가진다. 

### 서브 트리(Sub tree)

트리 구조의 root에서 뻗어 나오는 큰 트리의 내부에, **트리 구조를 갖춘 작은 트리를 서브 트**리라고 부른다. (D, H , I)로 이루어진 작은 트리도 서브 트리이고, (B, D, E)나 (C, F, G, J)도 서브 트리이다.

## Tree는 어디에서 사용할까?

가장 대표적으로는 컴퓨터의 디렉토리 구조이다. 어떤 프로그램이나 파일을 찾을 때, 바탕화면 폴더나 다운로드 폴더 등에서 다른 폴더에 진입하고, 또 그 안에서 다른 폴더에 진입하면서 원하는 프로그램이나 파일을 찾는다. 모든 폴더는 하나의 폴더(루트 폴더, `/` )에서 시작되어, 가지를 뻗어 나간다. 이 밖에도 토너먼트 대진표, 조직도, 가계보 등에서 사용된다.

# Binary Search Tree

트리 구조는 편리한 구조를 전시하는 것 외에 효율적인 탐색을 위해 사용하기도 한다. 그 중 가장 간단하고 많이 사용하는 이진 트리(binary tree)와 이진 탐색 트리(binary search tree)에 대해 알아보자

## 이진 트리(Binary tree)

자식 노드가 최대 두개인 노드들로 구성된 트리이다. 이 두 개의 자식 노드는 왼쪽 자식 노드와 오른쪽 자식 노드로 나눌 수 있다.

이진 트리는 자료의 삽입, 삭제 방법에 따라 정 이진 트리(Full binary tree), 완전 이진 트리(Complete binary tree), 포화 이진 트리(Perfect binary tree)로 나뉜다.

| 정 이진 트리 (Full binary tree) | 각 노드가 0개 혹은 2개의 자식 노드를 갖는다. |
| --- | --- |
| 포화 이진 트리 (Perfect binary tree) | 정 이진 트리이면서 완전 이진 트리인 경우이다. 모든 리프 노드의 레벨이 동일하고, 모든 레벨이 가득 채워져 있는 트리이다. |
| 완전 이진 트리 (Complete binary tree) | 마지막 레벨을 제외한 모든 노드가 가득 차 있어야 하고, 마지막 레벨의 노드는 전부 차 있지 않아도 되지만 왼쪽이 채워져야 한다.  |

## 이진 탐색 트리(Binary Search Tree)

**모든 왼쪽 자식의 값이 루트나 부모보다 작고, 모든 오른쪽 자식의 값이 루트나 부모보다 큰 값을 가지는 특성**이 있다. 

이진 탐색 트리는 균형 잡힌 트리가 아닐 때, 입력되는 값의 순서에 따라 한쪽으로 노드들이 몰리게 될 수 있다. 균형이 잡히지 않은 트리는 탐색하는 데 시간이 더 걸리는 경우도 있기 때문에 해결해야 할 문제이다. 이 문제를 해결하기 위해 삽입과 삭제마다 트리의 구조를 재조정하는 과정을 거치는 알고리즘을 추가할 수 있다.