# 목차
* [목차](#목차)
* [# JVM(Java Virtual Marchine)](#jvmjava-virtual-marchine)
    + [JVM 구조](#jvm-구조)
    + [JVM 메모리 구조](#jvm-메모리-구조)
        + [Stack](#stack)
        + [Heap](#heap)
    + [Garbage Collection](#garbage-collection)
        + [동작 방식](#동자)

# JVM(Java Virtual Marchine)

> Write Once, Run Anywhere
> 

> 자바로 작성한 소스 코드를 해석해 실행하는 별도의 프로그램
> 
- C++은 운영체제에 종속적이었기 때문에 각 운영체제 별로 프로그램을 만들어야하는 단점이 있었다.
- 자바는 JVM을 통해 운영체제로부터의 독립성을 갖게되었고 한 번 작성한 코드로 어떤 운영체제에서도 프로그램을 실행시킬 수 있다.
- JVM이 운영체제로부터 독립성을 갖게 되는 이유는 다음과 같다.
    1. 프로그램이 실행되기 위해서는 CPU, 메모리, 각종 입출력 장치 등과 같은 컴퓨터 자원을 프로그램이 할당 받아야 한다.
    2. 프로그램이 필요한 컴퓨터 자원을 운영체제에 주문하면, 운영체제는 가용한 자원을 확인한 다음, 프로그램이 실행되는 데 필요한 컴퓨터 자원을 프로그램에 할당해준다.
    3. 이 때, 프로그램이 컴퓨터 자원을 요청하는 방식이 운영체제마다 다르다. (이 부분때문에 기존 프로그래밍 언어가 운영체제에 대해 종속성을 갖게 된다.)
    4. 하지만 자바는 JVM을 통해 운영체제와 소통한다. 즉 JVM이 자바의 소스 코드를 운영체제에 맞게 변환하여 전달해주기 때문에 어떤 운영체제에서든 문제없이 프로그램을 실행시킬 수 있는 것이다.


## JVM 구조

자바 소스 코드를 작성하고 실행하면 어떤 일이 일어날까?

1. 자바 소스 코드를 작성하고 실행한다.
2. 컴파일러가 실행되면서 컴파일이 진행한다.
3. 컴파일의 결과로 .java 확장자를 가졌던 자바 소스 코드 → .class 확장자를 가진 바이트 코드 파일로 변환한다.
4. JVM은 운영 체제로부터 소스 코드 실행에 필요한 메모리르 할당 받는다. 해당 메모리 영역을 런타임 데이터 영역(Runtime Data Area)라고 한다.
5. 클래스 로더(Class Loader)가 바이트 코드 파일을 JVM 내부로 불러들여 런타임 데이터 영역에 적재시킨다. 자바 소스 코드를 메모리에 로드시키는 것이다.
6. 로드가 완료되면 실행 엔진(Excution Engine)이 런타임 데이터 영역에 적재도니 바이트 코드를 실행시킨다.
이 때, 실행 엔진은 두 가지 방식으로 바이트 코드를 실행한다.
    1. 인터프리터(Interpreter)를 통해 코드를 한 줄씩 기계어로 번역하고 실행
    2. JIT Compiler(Just-In-Time Compiler)를 통해 바이트 코드 전체를 기계어로 번역하고 실행
    
    실행 엔진은 기본적으로 인터프리터를 통해 바이트 코드를 실행시키다가, 특정 바이트 코드가 자주 실행되면 해당 바이트 코드를 JIT Compiler를 통해 실행시킨다.
    
    즉, 중복적으로 어떤 바이트 코드가 등장할 때, 인터프리터는 매 번 해당 바이트 코드를 해석하고 실행하지만, JIT 컴파일러가 동작하면 한 번에 바이트 코드를 해석하고 실행시킨다.
    

## JVM 메모리 구조


- JVM에 Java 프로그램이 로드되어 실행될 때 특정 값 및 바이트코드, 객체, 변수 등과 같은 데이터들이 메모리에 저장되어야 한다.
- 런타임 데이터 영역이 바로 이러한 정보를 담는 메모리 영역이며, 크게 5가지 영역으로 구분되어 있다. 이 중, Stack과 Heap을 알아보자

## Stack

- 스택은 일종의 자료구조이다. 자료구조는 프로그램이 데이터를 저장하는 방식을 의미한다.
- LIFO(Last In First Out) 방식으로, 마지막에 들어간 데이터가 가장 먼저 나온다.

### JVM 안에서 Stack은 어떻게 작동할까?

1. 메서드가 호출되면 메서드를 위한 Method Frame이 생성된다.
2. 메서드 내부에서 사용하는 다양한 값들이 임시로 저장된다.(참조변수, 매개변수, 지역변수, 리턴값, 연산시 일어나는 값)
3. 이런 Method Frame이 Stack에 호출되는 순서대로 쌓이게 되는데, Method의 동작이 완료되면 역순으로 제거된다.

## Heap

- 실제 객체의 값이 저장되는 공간이다.
- JVM에는 단 하나의 Heap 영역이 존재한다.
- JVM이 작동되면 자동 생성된다.
- 객체나 인스턴스, 배열이 저장된다.

```java
Person person = new Person();
```

- `new Person()` 이 실행되면 Heap 영역에 인스턴스가 생성되면서 인스턴스가 생성된 위치의 주소값을 `person` 에게 할당해주는데, 이 `person` 은 Stack 영역에 선언된 변수이다.
- 즉, 객체를 다룬다는 것은 Stack 영역에 저장되어 있는 참조 변수를 통해 Heap 영역에 존재하는 객체를 다룬다는 의미가 된다.
## Garbage Collection

> 프로그램에서 더 이상 사용하지 않는 객체를 찾아 삭제하거나 제거하여 메모리를 확보하는 프로세스
> 

```java
// 참조 변수 person은 Person 클래스의 인스턴스 주소값을 할당 받음
Person person = new Person(); 
// person이 가리킨 인스턴스의 name 속성에 "김코딩" 할당
person.setName("김코딩");
// person이 가리키던 인스턴스와 참조 변수 person간의 연결이 끊어짐
person = null; 
// 가비지 발생
person = new Person(); 
person.setName("박해커");
```

### 동작 방식

- 가비지 컬렉션의 동작 방식을 이해하려면 Heap 메모리 영역에 대한 이해가 필요하다.
- Heap 영역의 객체는 대부분 일회성이며, 메모리에 남아 있는 기간이 대부분 짧다는 전제로 설계되어 있다.
- Heap 영역 안에서는 객체가 얼마나 오래 살아있냐를 기준으로 Young, Old 영역 2가지로 나뉜다.

    - Young 영역 : 새롭게 생성된 객체가 할당되는 곳이다. 여기에는 많은 객체가 생성되었다 사라지는 것을 반복한다. 이 영역에서 활동하는 가비지 컬렉터를 Minor GC라고 부른다.
    - Old 영역 : Young 영역에서 상태를 유지하고 살아남은 객체들이 복사되는 곳으로 보통 Young 영역보다 크게 할당되고 크기가 큰 만큼 가비지는 적게 발생한다. 이 영역에서 활동하는 가비지 컬렉터를 Major GC라고 부른다.

- Young 영역과 Old 영역은 서로 다른 메모리 구조로 되어 있기 때문에, 세부적인 동작 방식은 다르지만 기본적으로 가비지 컬렉션이 실행될 때는 다음 2가지 단 계를 따른다.
    1. Stop The World
        
        가비지 컬렉션을 실행시키기 위해 JVM이 애플리케이션의 실행을 멈추는 작업이다. 
        
        가비지 컬렉션이 실행될 때 가비지 컬렉션을 실행하는 스레드를 제외한 모든 스레드들의 작업이 중단되고, 가비지 정리가 완료되면 재개된다.
        
    2. Mark and Sweep
        
        Mark는 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업을 의미하며, Sweep은 Mark단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업을 의미한다.
        
    
    즉, Stop The World를 통해 모든 작업이 중단되면, 가비지 컬렉션이 모든 변수와 객체를 탐색해서 각각 어떤 객체를 참고하고 있는지 확인한다. 
    
    이후, 사용되고 있는 메모리를 식별해서(Mark) 사용되지 않는 메모리는 제거(Sweep)하는 과정을 진행한다.