# 목차
* [목차](#목차)
* [클래스(Class)와 객체(Object)](#클래스class와-객체object)
    + [클래스(Class)](#클래스class)
        + [클래스 구성요소와 문법](#클래스-구성요소와-문법)
    + [객체(Object)](#객체object)
        + [객체 문법](#객체-문법)
        + [객체 활용](#객체의-활용)
* [필드(Field)와 메서드(Method)](#필드field와-메서드method)
    + [필드(Field)](#필드field)
        + [클래스 변수](#클래스-변수)
        + [인스턴스 변수](#인스턴스-변수)
        + [지역 변수](#지역-변수)
    + [static 키워드](#static-키워드)
    + [메서드(Method)](#메서드method)
        + [메서드 호출](#메서드-호출)
        + [메서드 오버로딩](#메서드-오버로딩)
* [생성자(Constructor](#생성자constructor)
    + [기본 생성자(Default Constructor)](#기본-생성자default-constructor)
    + [매개 변수가 있는 생성자](#매개-변수가-있는-생성자)
    + [this()](#this)
    + [this](#this-1)
* [내부 클래스(inner class)](#내부-클래스inner-class)


# 클래스(Class)와 객체(Object)

## 클래스(Class)

> 클래스(Class)란 객체를 생성하는 설계도(blueprint) 또는 틀(frame)이라고 정의할 수 있다. 즉, 클래스는 객체를 생성하는 데 사용되고, 객체는 클래스에 정의되고 설계된 내용대로 생성된다.
> 
- 여기서 중요한 점은 클래스는 **객체가 아니라 객체를 생성하는 틀**이라는 것이다. 클래스는 객체가 될 수 없다. (붕어빵 틀이 붕어빵이 될 수 없는 것처럼)
- 클래스를 통해 생성된 객체를 해당 클래스의 **인스턴스(instatnce)**라고 부른다. 클래스로부터 객체를 만드는 과정을 인스턴스화(instantiate)라고 부른다.
- 왜 클래스를 정의하고 객체를 생성해야 할까? 예를 들어 붕어빵을 만들 때 붕어빵 기계를 잘 만들어 놓으면 다음 붕어빵을 만들 때 고민할 필요 없이 바로 만들어 낼 수 있다. 이처럼 클래스를 잘 정의해 놓으면, 매번 객체를 생성할 때마다 매번 객체를 생성할 때마다 고민할 필요 없이 클래스로부터 객체를 생성하기만 하면 된다.

### 클래스 구성요소와 문법

- 클래스는 기본적으로 `class` 키워드를 사용하여 정의한다. 클래스명은 주로 대문자로 시작하는 것이 관례이다.

```java
class 클래스명 { //클래스 정의
	int x = 10;               //필드
	void printX(){...}        //메서드
	ExampleClass {...}        //생성자
	class ExampleClass2 {...} //이너 클래스
}
```

- 클래스는 크게 네가지의 구성요소로 구성되어 있다.
    1. 필드 : 클래스의 속성(state)를 나타내는 변수이다. 붕어빵 기계로 예를 들면 모델명, 컬러, 틀의 수 등이 포함된다.
    2. 메서드 : 클래스의 기능(behavior)을 나타내는 함수이다. 붕어빵 기계로 예를 들면 점화하기, 틀 뒤집기, 뚜껑 열기, 뚜껑 닫기 등이 포함된다.
    3. 생성자 : 클래스의 객체를 생성하는 역할을 한다.
    4. 이너 클래스 : 클래스 내부의 클래스를 의미한다.
- 생성자를 제외한 나머지 3가지 요소를 클래스의 멤버(member)라고 부른다.
- 필드와 클래스는 클래스와 관련된 데이터의 집합이며, 핵심적인 정보를 담고 있다.

## 객체(Object)

- 객체는 크게 속성과 기능이라는 두 가지 구성요소로 이루어져있다. 속성과 기능은 각각 필드와 메서드로 정의되고 이너클래스와 함께 객체의 멤버(member)라 부른다.

### 객체 문법

- `new` 키워드를 사용하여 객체를 생성할 수 있다.
- 객체를 생성한 후에는 포인트 연산자(`.`)를 통해 해당 객체의 멤버에 접근이 가능하다.

```java
클래스명 참조_변수명; // 인스턴스를 참조하기 위한 참조변수 선언
참조_변수명 = new 생성자(); // 인스턴스 생성 후, 객체의 주소를 참조 변수에 저장

//위 과정을 생략 할 수 있다.
클래스명 참조_변수명 = new 생성자();
```

- 여기서 참조 변수는 실제 데이터 값이 아니라 실제 데이터가 저장되어 있는 **힙 메모리의 주소값**을 가리킨다.
- `new` 키워드는 생성된 객체를 힙 메모리에 넣으라는 의미를 가지고 있다. 생성자를 통해 객체가 만들어지면 해당 객체를 힙 메모리에 넣는 역할을 수행하게 된다.
- 따라서 `new` 와 생성자를 통해 클래스의 객체를 생성한다는 것은 **해당 객체를 힙 메모리에 넣고 그 주소값을 참조변수에 저장하는 것**과 같다.
- 메서드 구현 코드는 클래스 영역에 저장되고 객체 안에서는 그 위치를 가르킨다. 즉, 같은 클래스로 만든 모든 객체는 동일한 메서드 값을 공유하기 때문에 필요할 때 메서드를 찾아 사용할 수 있다.

```java
class FB {
	public static void main(String[] args) {
	 
		FB bean = new FB();  //FB 클래스를 기반으로 생성된 bean 인스턴스
		FB cream = new FB();  //FB 클래스를 기반으로 생성된 cream 인스턴스
		FB chocolate = new FB();  //FB 클래스를 기반으로 생성된 chocolate 인스턴스
```

### 객체의 활용

- `.` 은 포인트 연산자라고 불리는데, **해당 위치에 있는 객체 안을 보세요**라는 뜻을 가지고 있다.
- `.` 을 사용해 특정 객체 안에 있는 필드 값 또는 메서드에 접근할 수 있다.

```java
참조 변수명.필드명 // 필드값 불러오기
참조 변수명.메서드명 // 메서드 호출
```

### 예제

붕어빵 기계를 예로 들어보자

| 붕어빵 |  |
| --- | --- |
| 속성 | 모델명, 틀의 개수, 컬러 |
| 기능 | 뒤집기, 점화, 뚜껑 열기, 뚜껑 닫기 |

```java
class FishBread {
	private String model; //붕어빵 기계 모델
	private int frame; //틀의 개수
	private String color; //컬러

	void reverse(){...}; //틀 뒤집기
	void fire(){...}; //점화하기
	void open(){...}; //뚜껑 열기
	void close(){...}; //뚜껑 닫기
```

# 필드(Field)와 메서드(Method)

## 필드(Field)

> 필드는 클래스에 포함된 변수를 의미하며, 객체의 속성을 정의할 때 사용된다.
> 

자바에서 변수는 크게 클래스 변수(cv, class variable), 인스턴스 변수(iv, instance variable), 그리고 지역 변수(lv, local variable)라는 세 가지로 구분될 수 있다. 

### 클래스 변수

- `static` 으로 선언된 변수.
- 공통된 저장공간을 공유한다.
- 한 클래스로부터 생성되는 모든 인스턴스들이 특정한 값을 공유해야하는 경우에 주로 `static` 을 사용하여 클래스 변수를 선언한다.
- 인스턴스를 따로 생성하지 않고도 언제라도 `클래스명.클래스변수명` 을 통해 사용이 가능하다.
- 메서드처럼 클래스 변수 또한 클래스 영역에 저장되어 그 값을 공유한다.

### 인스턴스 변수

- `static` 으로 선언되지 않은 변수.
- 인스턴스가 가지는 각각의 고유한 속성을 저장하기 위한 변수로 `new 생성자()` 를 통해 인스턴스가 생성될 때 만들어진다.

### 지역 변수

- 클래스 변수와 인스턴스 변수에 포함되지 않고 메서드 내에 포함된 모든 변수
- 메서드 내에 선언되며 메서드 내 `{ } 블록`에서만 사용 가능한 변수이다.
- 멤버 변수와는 다르게 지역변수는 스택 메모리에 저장되어 메서드가 종료되는 것과 동시에 함께 소멸되어 더 이상 사용할 수 없게 된다.
- 힙 메모리에 저장되는 필드 변수는 객체가 없어지지 않는 한 절대로 삭제되지 않는 반면, 스택 메모리에 저장되는 지역변수는 한동안 사용되지 않는 경우 가상 머신에 의해 자동으로 삭제된다.

```java
class Example { // 클래스 영역
	int intstanceVariable; // 인스턴스 변수
	static int classVariable; // 클래스 변수(static 변수, 공유변수)
	void method() { // 메서드 영역
		int localVariable = 0; // 지역 변수. {}블록 안에서만 유효
	}
}
```

- 필드 변수와 지역 변수의 중요한 한 가지 차이점은 초기값에 있다. 지역변수는 직접 초기화하지 않으면 값을 출력할 때 오류가 발생하는 반면 필드 변수는 직접적으로 초기화를 실행하지 않아도 강제로 초기화가 이루어진다.
- 이유는 힙 메모리는 빈 공간이 저장될 수 없기 때문에 이곳에 저장되는 피드는 강제로 초기화되지만, 스택 메모리는 초기화되지 않으므로 지역 변수는 선언시 반드시 초기화를 실행해주어야 한다.

## static 키워드

> `static` 은 클래스의 멤버(필드, 메서드, 이너 클래스)에 사용하는 키워드이다. 모든 객체와 메모리를 공유한다.
> 
- 인스턴스의 생성 없이도 `클래스명,멤버명` 만으로도 변수나 메서드 호출이 가능하다.
- `static` 으로 선언된 정적 멤버는 클래스 내부에 저장 공간을 가지고 있기 때문에 객체 생성 없이 곧바로 사용할 수 있다.

```java
public class StaticTest {
	public static void main(String[] args) {
		StaticExample staticExample = new StaticExample();
		System.out.println("인스턴스 변수: " + staticExample.num1); // static 키워드가 없는 인스턴스 변수
		System.out.println("클래스 변수: " + StaticExample.num2); // static 키워드가 있는 인스턴스 변수
	}
}

class StaticExample {
	int num1 = 10;
	static int num2 = -10;
}

//출력값
인스턴스 변수:  10
클래스 변수: -10
```

- 정적 필드는 객체 간 공유 변수의 성질이 있다. 모든 인스턴스에 공통적으로 적용되는 값을 공유할 수 있다는 것이다.
- 정적 메서드는 인스턴스 변수 또는 인스턴스 메서드를 사용할 수 없다. 인스턴스 생성 없이 호출이 가능하기 때문에 정적 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수 있기 때문이다.

```java
public class StaticFieldTest {
    public static void main(String[] args) {
        StaticField staticField1 = new StaticField(); // 객체 생성
        StaticField staticField2 = new StaticField();

        staticField1.num1 = 100;
        staticField2.num1 = 1000;

        System.out.println(staticField1.num1);
        System.out.println(staticField2.num1);

        staticField1.num2 = 150;
        staticField2.num2 = 1500;
        System.out.println(staticField1.num2);
        System.out.println(staticField2.num2);

    }
}

class StaticField {
    int num1 = 10;
    static int num2 = 15;
}

//출력값
100
1000
1500
1500
```

# 메서드(Method)

> 특정 작업을 수행하는 일련의 명령문들의 집합
> 
- 메서드는 메서드 시그니처(method signature)와 메서드(method body)로 구분할 수 있다.

```java
자바제어자 반환타입 메서드명(매개 변수) { // 메서드 시그니처
	메서드 내용 // 메서드 바디
}
```

- 메서드 시그니처는 순서대로 반환타입(해당 메서드가 어떤 타입을 반환하는지), 메서드명(메서드 이름이 무엇인지), 매개 변수(해당 작업을 수행하기 위해서 어떤 재료들이 필요한지)에 대한 정보를 포함한다.
- 메서드 바디는 괄호(`{}`)안에 메서드가 호출되었을 때 수행되어야하는 일련의 작업들을 표시하게 된다.
- 메서드명은 관례적으로 소문자로 표시한다.

```java
public static int add(int x, int y) {  // 메서드 시그니처
	int result = x + y;  // 메서드 바디
	return result;
}

// 메서드 명은 add. int타입 2개의 값(x, y)를 받아 더한 다음 int타입의 결과값을 반환하는 메서드
```

```java
void printHello() { // 반환타입이 void인 메서드
	System.out.println("Hello World!");
}

// void는 반환 값이 없는 메서드를 의미한다.
```

```java
int getNumberSeven() { //매개변수가 없는 메서드
	return 7;
}

// 그냥 숫자 7을 반환한다.
```

## 메서드 호출

- 메서드도 클래스의 멤버이므로 클래스 외부에서 메서드를 사용하기 위해서는 먼저 인스턴스를 생성해야한다. 포인트 연산자(`.`)를 통해 메서드를 호출 할 수 있다.
- 클래스 내부에 있는 메서드끼리는 따로 객체를 생성하지 않고도 서로를 호출할 수 있다.
- 메서드 호출 시 괄호( ) 안에 넣어주는 입력 값을 인자(argument)라고 하는데, 인자의 개수와 순서는 반드시 메서드를 정의할 때 선언된 매개변수와 일치되어야 한다.

```java
메서드이름(매개변수1, 매개변수2, ...); // 메서드 호출방법. 매개 변수가 없을 수도 있다.

void printHello();
int getNumseven();
int add(3, 4);

//출력
Hello World!
7
7
```

## 메서드 오버로딩

> 메서드 오버로딩이란 하나의 클래스 안에 같은 이름의 메서드를 여러 개 정의하는 것을 의미한다.
> 
- 오버로딩의 가장 큰 장점은 하나의 메서드로 여러 경우의 수를 해결할 수 있다.
- 오버로딩이 성립되기 위해서는 크게 두 가지 조건이 성립되어야 한다. 조건이 충족되지 않으면 중복 정의로 간주하고 컴파일 에러가 발생한다.
    - 메서드의 이름이 같아야 한다.
    - 매개변수의 개수나 타입이 달라야 한다.

```java
public class Overloading {
    public static void main(String[] args) {
        Shape s = new Shape();  // 객체 생성

        s.area();   // 메서드 호출
        s.area(5);
        s.area(10, 10);
        s.area(6.0, 12.0);
    }
}

class Shape {
    public void area() {    // 메서드 오버로딩. 같은 이름의 메서드 4개.
        System.out.println("넓이");
    }
    public void area(int r) {
        System.out.println("원 넓이 = " + 3.14 * r * r);
    }
    public void area(int w, int l) {
        System.out.println("직사각형 넓이 = " + w * l);
    }
    public void area(double b, double h) {
        System.out.println("삼각형 넓이 = " + 0.5 * b * h);
    }
}

// 출력
넓이
원 넓이 = 78.5
직사각형 넓이 = 100
삼각형 넓이 = 36.0
```

# 생성자(Constructor)

> 인스턴스 변수들을 초기화하는 데 사용되는 특수한 메서드. 인스턴스가 생성될 때 호출된다.
> 
- 생성자는 메서드와 두 가지 차이점이 있다.
    1. **생성자의 이름은 클래스의 이름과 같아야 한다.** 클래스 이름과 생성자 이름이 같지 않다면 생성자로서의 기능을 수행할 수 없다.
    2. **생성자는 리턴 타입이 존재하지 않는다.** 메서드에서 사용하는 void는 ‘리턴하지 않는다'는 의미를 가지고 있지만 생성자는 리턴 타입 자체가 존재하지 않는다.

```java
클래스명(매개변수) {  // 생성자 기본 구조
	...생략...
}
```

- 생성자도 오버로딩이 가능하다.

```java
public class ChickenSample {
	public static void main(String[] args) {
		Chicken chicken1 = new Chicken();
		Chicken chicken2 = new Chicken("BHC 뿌링클 존맛");
		Chicken chicken3 = new Chicken(7000, 20);

class Chicken {
	Chicken() {
		System.out.println("BBQ 생성자");
	}
	
	Chicken(String str) {
		System.out.println("BHC 생성자");
	}
	
	Chicken(int a, int b) {
		System.out.println("당당치킨 생성자);
	}
}

// 결과
BBQ 생성자
BHC 생성자
당당치킨 생성자
```

## 기본 생성자(Default Constructor)

- 모든 클래스는 반드시 하나 이상의 생성자가 존재해야 한다.
- 생성자를 따로 만들지 않으면 자바 컴파일러가 기본 생성자를 자동으로 추가해준다.
- 기본 생성자는 매개변수와 바디에 아무런 내용이 없다.
- 다른 생성자가 이미 있는 경우 기본 생성자가 아니라 추가되어어 있는 생성자를 기본으로 사용한다.

```java
클래스명(){}  // 기본 생성자

DefaultConst(){}  // EX.DefalutConst 클래스의 기본 생성자
```

## 매개 변수가 있는 생성자

- 매개변수를 통해 호출 시에 해당 값을 받아 인스턴스를 초기화하는 데 사용
- 고유한 특성을 가진 인스턴스를 계속 만들어야하는 경우 인스턴스마다 각기 다른 값을 가지고 초기화할 수 있어서 매우 유용하다.
- 매개변수가 있는 생성자를 사용하면 생성과 동시에 원하는 값으로 설정해줄 수 있어서 편리하다.

## this()

> this() 메서드는 자신이 속한 클래스에서 다른 생성자를 호출하는 경우에 사용한다.
> 
- `this()` 메서드를 사용하기 위해서는 두 가지의 문법 요소를 충족시켜야 한다.
    1. 반드시 생성자의 내부에서만 사용할 수 있다.
    2. 반드시 생성자의 첫 줄에 위치해야 한다.

```java
public class Test {
    public static void main(String[] args) {
        Example example = new Example();
        Example example2 = new Example(3);
	}
}

class Example {
	public Example() {
		System.out.println("기본 생성자");
	}
	
	public Example(int a) {
		this();
		System.out.println("매개변수가 있는 생성자");
	}
}

// 결과
기본생성자
기본생성자
매개변수가 있는 생성자
```

## this

> this는 인스턴스 자신을 가리키며, this를 통해서 인스턴스 자신의 변수에 접근할 수 있다.
> 
- 자바에서는 지역 변수명이 필드명과 동일하게 구성하기때문에 필드명과 지역변수를 구분하기 위한 용도로 사용된다.
- 모든 메서드에는 자신이 포함된 클래스의 객체를 가리키는 this라는 참조변수가 있는데, 컴파일러가 `this.` 를 자동으로 추가해준다.

```java
class Chicken {
    private String brandName;
    private String bestMenu;

    public Chicken(String brandName, String bestMenu) {
        this.bestMenu = bestMenu;  // 필드 변수 bestMenu에 지역 변수 bestMenu 선언
        this.brandName = brandName;
    }

    public String getBrandName() {
        return brandName;
    }

    public String getBestMenu () {
        return bestMenu;
    }
}

public class Main {
    public static void main(String[] args) {
        Chicken bbq = new Chicken("BHC", "뿌링클");
        System.out.println("나는 " + bbq.getBrandName() + "의 " + bbq.getBestMenu() + "을 가장 좋아합니다.");
    }
}

// 결과
나는 BHC의 뿌링클을 가장 좋아합니다.
```

# 내부 클래스(Inner Class)

> 클래스 내부에 선언된 클래스
> 
- 내부 클래스를 사용하면 외부 클래스의 멤버들에 쉽게 접근할 수 있고, 코드의 복잡성을 줄일 수 있다.
- 외부적으로 불필요한 데이터를 감출 수 있어 객체지향의 중요한 핵심 원칙인 캡슐화(encapsulation)를 달성하는 데 유용하다.
- 내부 클래스의 종류는 세 가지가 있다.

| 종류 | 선언 위치 | 사용 가능한 변수 |
| --- | --- | --- |
| 인스턴스 내부 클래스(instance inner class) | 외부 클래스의 멤버변수 선언 위치에 선언(멤버 내부 클래스) | 외부 인스턴스 변수, 외부 전역 변수 |
| 정적 내부 클래스(static inner class) | 외부 클래스의 멤버변수 선언 위치에 선언(멤버 내부 클래스) | 외부 전역 변수 |
| 지역 내부 클래스(local inner class) | 외부 클래스의 메서드나 초기화블럭 안에 선언 | 외부 인스턴스 변수, 외부 전역 변수 |
| 익명 내부 클래스(anonymous inner class) | 클래스의 선언과 객체의 생성을 동시에 하는 일회용 익명 클래스 | 외부 인스턴스 변수, 외부 전역 변수 |

```java
class Outer { // 외부 클래스
	
	class Inner {
		// 인스턴스 내부 클래스	
	}
	
	static class StaticInner {
		// 정적 내부 클래스
	}

	void run() {
		class LocalInner {
		// 지역 내부 클래스
		}
	}
}
```