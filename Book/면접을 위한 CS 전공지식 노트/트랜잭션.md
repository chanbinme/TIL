# 트랜잭션

트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말한다. 즉, 데이터베이스에 접근하기 위한 여러 개의 쿼리를 하나로 묶는 단위를 말하는 것이다.

트랜잭션은 4가지 특징이 있으며 이를 ACID라고 부른다.

- 원자성 (Atomicity)
- 일관성 (Consistancy
- 독립성 (Isolation)
- 지속성 (Durability)

## 원자성

> all or nothing
>

원자성은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장한다. 쉽게 말해 하나의 작업이 제대로 수행되지 않으면 모든 작업이 수행되지 않는 것을 보장한다는 의미이다.

![Untitled](https://user-images.githubusercontent.com/108569685/230560578-5f2ca5f9-7e1f-4fb3-94c7-e75ca49a2700.png)

예를 들어 군대에 가 본 사람들이라면 알 것이다. 훈련병 때 팔벌려뛰기를 하면 마지막 번호는 외치면 안됐었다. 하지만 단 한 사람이라도 마지막 번호를 외친다면.. 모든 훈련병들은 처음부터 팔벌려뛰기를 해야 했다. all or nothing의 대표적인 사례이지 않을까 싶다.

보통은 계좌이체를 예로 많이 든다. A가 B에게 계좌이체를 하려고 했을 때 A에는 출금이 되었는데 오류로 인해 B에는 입금이 되지 않았다면 B는 돈도 받지 못하고 A는 돈만 잃어버리게 된다. 실제로 이런 일이 벌어진다면 은행은 망할 것이다. 여기서 A의 출금은 성공했더라도 B에게 입금하는 작업이 실패했다면 A의 출금을 포함한 모든 작업이 실패로 돌아가야 한다는 것이 원자성이다.

여러 로직을 트랜잭션 단위로 묶을 때 외부 API를 호출하면 안된다. 만약 있다면 롤백이 일어났을 때 외부 API에도 트랜잭션이 적용될 수 있도록 트랜잭션 전파에 신경 써야 한다.

### 커밋과 롤백

![Untitled](https://user-images.githubusercontent.com/108569685/230560676-535b974f-d667-4847-b639-4174c61ec38a.png)

**커밋(commit)**

- 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어.
- 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말한다.
- “커밋이 수행되었다”를 “하나의 트랜잭션이 성공적으로 수행되었다.”라고 볼 수 있다.
- update, insert, delete의 쿼리가 하나의 트랜잭션 단위로 수행되고 이후에 데이터베이스에 영구 저장된다.

![Untitled](https://user-images.githubusercontent.com/108569685/230561108-6838992e-61be-46ad-a3c4-8292c0a2ddb8.png)

**롤백(rollback)**

- 작업 중 문제가 발생했을 때, 트랜잭션 처리 과정에서 발생한 변경 사항을 취소하고, 트랜잭션 단위가 묶이기 이전의 상태로 되돌릴 수 있다.
- 커밋과 롤백 덕에 데이터의 무결성이 보장된다. 또한, 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있다.

### 트랜잭션 전파

트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 한다. 하지만 이를 매번 넘겨주기 어렵고 귀찮기 때문에 트랜잭션 관련 메서드 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 한다.

Spring Framework에서는 @Transactional 애너테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리한다.

```java
@Service
@Transactional
public class MemberService {
		private final MemberRepository memberRepository;
		
		...
}
```

## 일관성

일관성은 허용된 방식으로만 데이터를 변경해야 한다는 것을 의미한다. 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다는 뜻이다.

예를 들어 ‘모든 고객의 이름은 문자열이어야 한다’는 데이터베이스의 제약이 있다고 가정해보자. 이럴 경우 아래와 같은 트랜잭션은 일관성을 위반한다.

- 이름이 없는 고객을 추가하는 쿼리
- 고객의 이름을 정수형으로 추가하는 쿼리

## 격리성, 고립성

격리성은 모든 트랜잭션은 다른 트랜잭션으로부터 독립적이어야 한다는 것을 의미한다. 복수의 병렬 트랜잭션이 서로 격리되어서 마치 순차적으로 실행되는 것처럼 작동되어야 한고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 한다. 그렇다고 순차적으로 실행하게 되면 성능이 나빠질 것이다.

격리성은 여러 개의 격리 수준으로 나누어 격리성을 보장한다.

격리 수준은 위로 갈수록 동시성이 강해지지만 격리성은 약해지고, 아래로 갈수록 동시성은 약해지고 격리성은 강해진다. 그리고 각 단계마다 나타는 현상이 있다.

| 레벨 | 더티 리드 | 반복 불가능한 조회  | 팬텀 리드 |
| --- | --- | --- | --- |
| READ_UNCOMMITED | 가능 | 가능 | 가능 |
| READ_COMMITED | 불가능 | 가능 | 가능 |
| REPEATABLE_READ | 불가능 | 불가능 | 가능 |
| SERIALIZABLE | 불가능 | 불가능 | 불가능 |

### 격리 수준에 따라 발생하는 현상

**더티 리드**

더티 리드는 특정 트랜잭션에 의해 데이터가 변경되었지만, 아직 커밋되지 않은 상황에서 다른 트랜잭션이 해당 변경 사항을 조회할 수 있는 문제를 말한다.

**반복 불가능한 조회**

같은 트랜잭션 내에서 같은 데이터를 여러번 조회했을 때 읽어온 데이터가 다른 경우를 의미한다.

**팬텀 리드**

팬텀 리드는 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말한다.

### 격리 수준

**SERIALIZABLE**

트랜잭션을 순차적으로 진행시키는 것을 말한다. 특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠급니다. 가장 높은 격리 수준을 갖지만 성능은 가장 떨어진다.

이 격리 수준에서는 단순한 SELECT 쿼리가 실행되더라도 데이터베이스에 락이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없다.

**REPEATABLE_READ**

특정 행을 조회시 항상 같은 데이터를 응답하는 것을 보장하는 격리 수준이다. 하지만 행이 추가되는 것을 막지는 않는다. 이로 인해 팬텀 리드가 발생할 수 있다.

MySQL의 InnoDB 엔진의 기본 격리 수준이 REPEATABLE_READ이다.

![Untitled](https://user-images.githubusercontent.com/108569685/230561237-45aadcdb-fe74-4fff-a1bc-cf4598ebdafd.png)

**READ_COMMIT**

커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용하는 격리 수준이다. 즉, 특정 트랜잭션이 이루어지는 동안 다른 트랜잭션은 해당 데이터에 접근할 수 없다. 가장 많이 사용되는 격리 수준이며, 오라클 등에서 기본값으로 설정되어 있다.

특정 트랜잭션에서 데이터가 변경되었으나, 아직 커밋되지 않은 상태라면 다른 트랜잭션에서는 해당 데이터에 접근했을 때 틀내잭션 시작 전 데이터를 읽어온다. 커밋이 된 이후에서야 변경된 데이터 값을 읽어올 수 있다.

하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다. 이 때문에 반복 불가능한 조회, 팬텀 리드 문제가 발생할 수 있다.

![Untitled](https://user-images.githubusercontent.com/108569685/230561296-2c308a61-d1b6-490e-9631-aec277c2a26c.png)

**READ_UNCOMMITED**

커밋이 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 죄회하는 것을 허용하는 격리 수준이다. 데이터 부정합 문제가 발생할 확률이 높지만, 성능은 가장 빠르다. 데이터를 어림잡아 집계하는 등의 연산에서 사용하는 것이 좋다.

![Untitled](https://user-images.githubusercontent.com/108569685/230561351-f20da118-709d-4f6c-be71-3e2480654845.png)

## 지속성

지속성은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미한다. 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 한다는 뜻이다. 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공한다.

### 체크섬

중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법

### 저널링

파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것