# 인덱스 

## 인덱스의 필요성

인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다. 책의 페이지를 생각하면 된다. 책의 본문 중 내가 읽고 싶은 내용의 페이지를 안다면 빠르게 찾을 수 있다.

## 트리

인덱스는 보통 B+tree라는 자료 구조로 이루어져 있다. 이는 루트 노드, 리프 노드, 브랜치 노드로 나뉜다.

- B+tree는 오직 리프 노드에만 key와 data를 저장하고 다른 노드에는 key만 담아둔다.
- 리프 노드는 Linked list로 연결되어 있어서 선형검사를 수행할 수 있어 시간 복잡도가 굉장히 빠르다.

트리 탐색은 맨위 루트 노드부터 탐색이 일어나며 브랜치 노드를 거쳐 리프 노드까지 내려온다. 리프노드에 도달해서 해당하는 key를 가르키는 데이터 포인터를 통해 결괏값을 반환하게 된다.

![Untitled](https://user-images.githubusercontent.com/108569685/230560269-daf0fe05-7015-49d5-b73f-4eda064b16db.png)

## 인덱스가 효율적인 이유와 대수확장성

인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊의 대수 확장성 때문이다.

대수 확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미한다. 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수가 4배씩 증가한다.

| 트리 깊이 | 인덱스 항목의 수 |
| --- | --- |
| 3 | 64 |
| 4 | 256 |
| 5 | 1,024 |
| 6 | 4,096 |
| 7 | 16,384 |
| 8 | 65,536 |
| 9 | 262,144 |
| 10 | 1,048,576 |

위의 표처럼 트리 깊이 열 개로 100만개의 레코드를 검색할 수 있다. (아주 효율적이다)

## 인덱스 만드는 방법

인덱스를 마드는 방법은 데이터베이스마다 다르다. MySQL과 MongoDB를 기준으로 알아보자

### MySQL

MySQL은 클러스터형 인덱스와 세컨더리 인덱스가 있다. 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋다.

- 클러스터형 인덱스: 테이블 당 하나를 설정할 수 있다. primary key 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있고, 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.
- 세컨더리 인덱스: create index… 명령어를 기반으로 만들 수 있다. 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성하는 인덱스이다. 예를 들어 age라른 하나의 필드만으로 쿼리를 보낸다면 클러스터형 인덱스만 필요하겠지만 age, name, email 등 다양한 필드를 기반으로 쿼리르 본래 때는 세컨더리 인덱스를 사용해야 한다.

### MongoDB

MongoDB는 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정된다. 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있다.

## 인덱스 최적화 기법

인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같다. MySQL을 기준으로 설명한다.

### 테스트하자

인덱스 최적화 기법은 서비스 특징에 따라 다르다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문이다. 그렇기 때문에 항상 테스팅하는 것이 중요하다. explain()함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하면 걸리는 시간을 최소화해야 한다.

```sql
explain
select *
from test.users u
order by u.user_id desc
limit 10
offset 10000;
```

### DB 스키마를 적절하게 설계하고 인덱싱하자

열에 적절한 데이터 유형 사용하면 필요한 스토리지 공간을 줄이고 쿼리 성능을 향상시키는데 도움이 될 수 있다. 그 외에 정규화를 통해 테이블 간의 관계를 사용하여 데이터를 연결하면 중복성을 줄이고 쿼리 속도를 향상시키는 데 도움이 된다.

### 캐싱 레이어 사용

Memcached 및 Redis와 같은 캐싱 시스템은 자주 액세스하느 데이터를 메모리에 저장하여 트래픽이 많은 웹 사이트의 성능을 향상시킬 수 있다. 이것은 MySQL 서버의 부하를 줄이고 쿼리 속도를 향상시킬 수 있다.

### MySQL 구성 조정

- query_cache_size: 이 옵션은 동일한 쿼리가 다시 실행될 때 더 빨리 제공될 수 있도록 SELECT 쿼리의 결과를 저장하는 MySQL 쿼리 캐시에 할당된 메모리 양을 결정한다.
- innodb_buffer_pool_size: InnoDB 스토리지 엔진이 사용하는 버퍼 풀의 크기를 결정한다. 이 값을 늘리면 특히 메모리가 많은 시스템에서 성능이 향상된다.
- join_buffer_size: 인덱스를 사용하지 않는 전체 테이블 스캔 및 조인에 사용되는 버퍼의 크기를 결정한다. 이 값을 늘리면 이러한 쿼리의 성능이 향상될 수 있다.

### MySQL의 performance_schema를 사용

peformance_schema는 MySQL 서버 및 다양한 구성 요소의 성능에 대한 자세한 정보를 모니터링하는 기능이다 이 정보를 사용하여 성능 문제를 식별하고 해결할 수 있다.

### 데이터베이스를 정기적으로 유지 관리

OPTIMIZE TABLE 명령어로 테이블을 분석하고 조각 모음하여 성능을 향상시킬 수 있다. 삽입, 업데이트 및 삭제 작업을 많이 수행한 대형 테이블에 특히 유용하다.