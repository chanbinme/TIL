# 목차
* [목차](#목차)
* [재귀](#재귀)
    + [재귀 함수](#재귀-함수)
        + [장점](#장점)
        + [단점](#단점)
        + [사용 조건](#사용-조건)
        + [사용 방법](#사용-방법)
        + [예제](#예제---반복문-vs-재귀)

        
# 재귀

> 원래의 자리로 되돌아가거나 되돌아옴.
> 

## 재귀 함수

- 자기 자신을 호출하는 함수를 재귀 함수라고 한다.

```java
public void revursion() {
	System.out.println("This is");
	Sytem.out.println("recurison!");
	recursion();
}

// 결과
This is
recursion!!
This is
recursion!!
This is
recursion!!
This is
recursion!!
.
.
.
```

## 장점

- 불필요하게 여러개의 반복문을 사용하지 않기 때문에, 코드가 간결해지고, 수정이 용이하다.
- 변수를 여러개 사용할 필요가 없다.

## 단점

- 반복문과 달리, 코드의 흐름을 직관적으로 파악하기 어렵다.
- 반복하여 메서드를 호출하며 지역변수, 매개변수, 반환값을 모두 process stack에 저장하게 된다. 이러한 과정은 반복문에 비해서 메모리를 더 많이 사용하게 된다.
- 메서드를 호출하고 메서드가 종료된 이후에 복귀를 위한 컨텍스트 스위칭 비용이 발생한다.

## 사용 조건

- 문제의 크기를 점점 작은 단위로 쪼갤 수 있어야 한다.
- 재귀 호출이 종료되는 시점이 존재해야 한다.

## 사용 방법

```java
class Sum {
    public int arrSum(int[] arr) {
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
}
```

위 반복문을 재귀 함수로 해결해보자

1. 문제를 좀 더 작게 쪼갠다.
2. 문제가 더는 작아지지 않을 때까지, 가장 작은 단위로 문제를 쪼갠다.
3. 가장 작은 단위의 문제를 해결함으로써 전체 문제를 해결한다.

### 1. 문제를 작게 쪼개기

[1, 2, 3, 4, 5]의 합을 구한다고 가정해보자

```java
arrSum([1, 2, 3, 4, 5]) == 1 + arrSum([2, 3, 4, 5])
arrSum([2, 3, 4, 5]) == 2 + arrSum([3, 4, 5])
...
```

### 2. 문제를 가장 작은 단위로 쪼갠다

```java
...
arrSum([3, 4, 5]) == 3 + arr([4, 5])
arrSum([4, 5]) == 4 + arr([5])
arrSum([5]) == 5 + arr([])
```

arrSum이 빈 배열을 받게되면서 문제를 더 이상 쪼갤 수 없게 되었다. 문제를 가장 작은 단위까지 쪼갰다고 할 수 있게 되었다.

### 3. 문제 해결하기

문제가 더 쪼개지지 않게되면, 가장 작은 단위의 문제를 해결한다. 같은 방식으로 쪼갰기 때문에, 가장 작은 단위의 문제를 해결한 방식으로 문제 전체를 해결할 수 있게 됐다. 

가장 작은 문제는 arrSum([])이었다. 빈 배열의 합은 0이므로, 0을 리턴해면 된다. 이렇게 가장 작은 문제를 해결하는 순간, 아래 코드처럼 쪼개졌떤 문제가 거꾸로 거슬러 올라가면서 합쳐지게 된다.

```java
arrSum([]) == 0; // 문제가 더는 작아지지 않는 순간
// 가장 작은 경우의 해결책을 적용한다.
arrSum([5]) == 5 + arrSum([]) == 5 + 0 == 5;
arrSum([4, 5]) == 4 + arr([5]) == 4 + 5 == 9;
arrSum([3, 4, 5]) == 3 + arr([4, 5]) == 3 + 9 == 12;
arrSum([2, 3, 4, 5]) == 2 + arr([3, 4, 5]) == 2 + 12 == 14;
arrSum([1, 2, 3, 4, 5]) == 1 + arr([2, 3, 4, 5]) == 1 + 14 == 15;
```

위 단계를 적용해서 arrSum 메서드를 완성해보면

```java
public int arrSum(int[] arr) {
	// 빈 배열을 받앗을 때 0을 리턴하는 조건문
	// 가장 작은 문제를 해결하는 코드 & 재귀를 먼추는 코드
	if (arr.length == 0) {
		return 0;
	}
	
	int[] tail = Arrays.copyOfRange(arr, 1, arr.length); 

	// 배열의 첫 요소 + 나머지 요소가 담긴 배열을 받는 arrSum 함수
	// 재귀(자기 자신을 호출)을 통해 문제를 작게 쪼개 나가는 코드
	return arr[0] + arrSum(tail);
}
```

arrSum 메서드가 내부에서 arrSum 메서드를 호출하면서 문제가 쪼개어져 나가고, 결국 문제를 더 이상 쪼갤 수 없는 arrSum([])까지 메서드가 호출된다.

arrSum([])는 조건문에 의해 더 이상 자신을 호출하지 않고, 숫자 0을 리턴하면서 종료된다. 그 결과 중첩되어 있떤 메서드들도 연쇄적으로 숫자를 리턴하고, 최종적으로 배열의 모든 요소의 합을 리턴하면서 문제가 해결된다. 

## 예제 - 반복문 vs 재귀

재귀는 다음과 같은 상황에서 매우 적합하다.

1. 주어진 문제를 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우
2. 중첩도니 반복문이 많거나 반복문의 중첩 횟수(number of loops)를 예측하기 어려운 경우
3. 변수 사용을 줄여 mutable state( 변경 가능한 상태)를 제거하여 프로그램 오류가 발생할 수 있는 가능성을 줄이는 경우

```java
for(int i = 0; i < n; i++) {
	for(int j = 0; j < n; j++) {
		for(int k = 0; k < n; k++) {
			for(int l = 0; l < n; l++) {
				for(int m = 0; m < n; m++) {
					// do something
					someFunc(i, j, k, l, m);
				}
			}
		}
	}
}
```

모든 재귀 함수는 반복문으로 표현할 수 있다. 그러나 재귀를 적용할 수 있는 대부분의 경우에는, 재귀를 적용한 코드가 더욱 간결하고 이해하기 쉽다. 

이 밖에도, 재귀는 알고리즘 문제의 많은 부분을 차지한다. 코딩테스트, 알고리즘 테스트 등이나 직무 면접에서 활용할 수 있기 때문에, 기초를 확실하게 다져두는게 바람직하다.